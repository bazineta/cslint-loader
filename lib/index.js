// Generated by CoffeeScript 1.12.5
var Lint, LintError, LintType, _, async, coffeelint, getConfig, loadReporter, normalize, report, utils,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

async = require('async');

coffeelint = require('coffeelint');

utils = require('loader-utils');

getConfig = require('coffeelint/lib/configfinder').getConfig;

LintError = (function(superClass) {
  extend(LintError, superClass);

  function LintError(message) {
    this.message = message;
    this.name = this.constructor.name;
  }

  return LintError;

})(Error);

LintType = (function() {
  function LintType() {
    this.lines = [];
  }

  LintType.prototype.count = function() {
    return this.lines.length;
  };

  LintType.prototype.error = function(error) {
    var line;
    line = "\nLine " + error.lineNumber + ": " + error.message;
    if (error.context) {
      line += ": " + error.context;
    }
    this.lines.push(line);
  };

  LintType.prototype.check = function(arg, callback) {
    var emit, error, fail;
    fail = arg.fail, emit = arg.emit;
    if (this.count()) {
      error = new LintError(this.lines.join());
      if (fail) {
        return callback(error);
      }
      emit(error);
    }
    return callback(null);
  };

  return LintType;

})();

Lint = (function() {
  function Lint(errorReport) {
    this.type = {
      error: new LintType(),
      warn: new LintType()
    };
    _.forEach(errorReport.paths, (function(_this) {
      return function(errors) {
        var error, i, len;
        for (i = 0, len = errors.length; i < len; i++) {
          error = errors[i];
          _this.type[error.level].error(error);
        }
      };
    })(this));
  }

  Lint.prototype.count = function() {
    return _.sum(_.invokeMap(this.type, 'count'));
  };

  return Lint;

})();

loadReporter = function(type) {
  if (_.isFunction(type)) {
    return type;
  }
  if (type == null) {
    type = 'coffeelint-stylish';
  }
  try {
    return require("coffeelint/lib/reporters/" + type);
  } catch (error1) {}
  try {
    return require(type);
  } catch (error1) {}
  throw new Error(type + " is not a valid reporter");
};

report = function(errorReport, options) {
  var instance, reporter;
  reporter = loadReporter(options.reporter);
  instance = new reporter(errorReport);
  instance.publish();
};

normalize = function(resourcePath) {
  var cwd;
  cwd = process.cwd() + '/';
  if (_.startsWith(resourcePath, cwd)) {
    return resourcePath.slice(cwd.length);
  }
  return resourcePath;
};

module.exports = function(input) {
  var callback, errorReport, options, resourcePath;
  resourcePath = normalize(this.resourcePath);
  errorReport = coffeelint.getErrorReport();
  callback = _.partialRight(this.async(), input);
  options = utils.getOptions(this);
  return async.setImmediate((function(_this) {
    return function() {
      var lint;
      errorReport.lint(resourcePath, input, getConfig(_this.context));
      if (!(lint = new Lint(errorReport)).count()) {
        return callback(null);
      }
      report(errorReport, options);
      return async.parallel([
        function(callback) {
          return lint.type.error.check({
            fail: options.failOnError,
            emit: _this.emitError
          }, callback);
        }, function(callback) {
          return lint.type.warn.check({
            fail: options.failOnWarning,
            emit: _this.emitWarning
          }, callback);
        }
      ], callback);
    };
  })(this));
};
